{
  "contract_name": "token-bridge-terra-2",
  "contract_version": "0.1.0",
  "idl_version": "1.0.0",
  "instantiate": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "InstantiateMsg",
    "description": "The instantiation parameters of the token bridge contract. See [`crate::state::ConfigInfo`] for more details on what these fields mean.",
    "type": "object",
    "required": [
      "chain_id",
      "gov_address",
      "gov_chain",
      "native_decimals",
      "native_denom",
      "native_symbol",
      "wormhole_contract",
      "wrapped_asset_code_id"
    ],
    "properties": {
      "chain_id": {
        "type": "integer",
        "format": "uint16",
        "minimum": 0.0
      },
      "gov_address": {
        "$ref": "#/definitions/Binary"
      },
      "gov_chain": {
        "type": "integer",
        "format": "uint16",
        "minimum": 0.0
      },
      "native_decimals": {
        "type": "integer",
        "format": "uint8",
        "minimum": 0.0
      },
      "native_denom": {
        "type": "string"
      },
      "native_symbol": {
        "type": "string"
      },
      "wormhole_contract": {
        "type": "string"
      },
      "wrapped_asset_code_id": {
        "type": "integer",
        "format": "uint64",
        "minimum": 0.0
      }
    },
    "definitions": {
      "Binary": {
        "description": "Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.\n\nThis is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>",
        "type": "string"
      }
    }
  },
  "execute": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "ExecuteMsg",
    "oneOf": [
      {
        "type": "object",
        "required": [
          "register_asset_hook"
        ],
        "properties": {
          "register_asset_hook": {
            "type": "object",
            "required": [
              "chain",
              "token_address"
            ],
            "properties": {
              "chain": {
                "type": "integer",
                "format": "uint16",
                "minimum": 0.0
              },
              "token_address": {
                "$ref": "#/definitions/ExternalTokenId"
              }
            }
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "deposit_tokens"
        ],
        "properties": {
          "deposit_tokens": {
            "type": "object"
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "withdraw_tokens"
        ],
        "properties": {
          "withdraw_tokens": {
            "type": "object",
            "required": [
              "asset"
            ],
            "properties": {
              "asset": {
                "$ref": "#/definitions/AssetInfo"
              }
            }
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "initiate_transfer"
        ],
        "properties": {
          "initiate_transfer": {
            "type": "object",
            "required": [
              "asset",
              "fee",
              "nonce",
              "recipient",
              "recipient_chain"
            ],
            "properties": {
              "asset": {
                "$ref": "#/definitions/Asset"
              },
              "fee": {
                "$ref": "#/definitions/Uint128"
              },
              "nonce": {
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              },
              "recipient": {
                "$ref": "#/definitions/Binary"
              },
              "recipient_chain": {
                "type": "integer",
                "format": "uint16",
                "minimum": 0.0
              }
            }
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "initiate_transfer_with_payload"
        ],
        "properties": {
          "initiate_transfer_with_payload": {
            "type": "object",
            "required": [
              "asset",
              "fee",
              "nonce",
              "payload",
              "recipient",
              "recipient_chain"
            ],
            "properties": {
              "asset": {
                "$ref": "#/definitions/Asset"
              },
              "fee": {
                "$ref": "#/definitions/Uint128"
              },
              "nonce": {
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              },
              "payload": {
                "$ref": "#/definitions/Binary"
              },
              "recipient": {
                "$ref": "#/definitions/Binary"
              },
              "recipient_chain": {
                "type": "integer",
                "format": "uint16",
                "minimum": 0.0
              }
            }
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "submit_vaa"
        ],
        "properties": {
          "submit_vaa": {
            "type": "object",
            "required": [
              "data"
            ],
            "properties": {
              "data": {
                "$ref": "#/definitions/Binary"
              }
            }
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "create_asset_meta"
        ],
        "properties": {
          "create_asset_meta": {
            "type": "object",
            "required": [
              "asset_info",
              "nonce"
            ],
            "properties": {
              "asset_info": {
                "$ref": "#/definitions/AssetInfo"
              },
              "nonce": {
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              }
            }
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "complete_transfer_with_payload"
        ],
        "properties": {
          "complete_transfer_with_payload": {
            "type": "object",
            "required": [
              "data",
              "relayer"
            ],
            "properties": {
              "data": {
                "$ref": "#/definitions/Binary"
              },
              "relayer": {
                "type": "string"
              }
            }
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "Asset": {
        "type": "object",
        "required": [
          "amount",
          "info"
        ],
        "properties": {
          "amount": {
            "$ref": "#/definitions/Uint128"
          },
          "info": {
            "$ref": "#/definitions/AssetInfo"
          }
        }
      },
      "AssetInfo": {
        "description": "AssetInfo contract_addr is usually passed from the cw20 hook so we can trust the contract_addr is properly validated.",
        "oneOf": [
          {
            "type": "object",
            "required": [
              "token"
            ],
            "properties": {
              "token": {
                "type": "object",
                "required": [
                  "contract_addr"
                ],
                "properties": {
                  "contract_addr": {
                    "type": "string"
                  }
                }
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "native_token"
            ],
            "properties": {
              "native_token": {
                "type": "object",
                "required": [
                  "denom"
                ],
                "properties": {
                  "denom": {
                    "type": "string"
                  }
                }
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "Binary": {
        "description": "Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.\n\nThis is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>",
        "type": "string"
      },
      "ExternalTokenId": {
        "description": "Represent the external view of a token address. This is the value that goes into the VAA.\n\nWhen given an external 32 byte address, there are 3 options: I. This is a token native to this chain a. it's a token managed by the Bank cosmos module (e.g. the staking denom \"uluna\" on Terra) b. it's a CW20 token II. This is a token address from another chain\n\nThus, interpreting an external token id requires knowing whether the token in question originates from this chain, or another chain. This information will always be available from the context.\n\nI. //////////////////////////////////////////////////////////////////////////\n\nIn the first case (native tokens), the layout of is the following:\n\n| 1 byte |                          31 bytes                               | +--------+-----------------------------------------------------------------+ | MARKER |                           HASH                                  | +--------+-----------------------------------------------------------------+\n\nThe left-most byte (MARKER) tells us whether it's a Bank token (1), or a CW20 (0). Since denom names can be arbitarily long, and CW20 addresses are 32 byes, we cannot directly encode them into the remaining 31 bytes. Instead, we hash the data (either the denom or the CW20 address), and put the last 31 bytes of the hash into the address (HASH). In particular, this choice reduces the space of the hash function by 8 bits, but assuming the hash is resistant to differential attacks, we consider giving up on these 8 bits safe.\n\nIn order to be able to recover the denom and the contract address later, we store a mapping from these 32 bytes (MARKER+HASH) to denoms and CW20 addresses (c.f. [`native_cw20_hashes`] & [`bank_token_hashes`] in state.rs)\n\nII. /////////////////////////////////////////////////////////////////////////\n\nIn the second case (foreign tokens), the whole 32 bytes correspond to the external token address. In this case, the corresponding token will be a wrapped asset, whose address is stored in storage as a mapping (c.f. [`wrapped_asset`] in state.rs)\n\n(chain_id, external_id) => wrapped_asset_address\n\nFor internal consumption of these addresses, we first convert them to [`TokenId`] (see below).",
        "type": "object",
        "required": [
          "bytes"
        ],
        "properties": {
          "bytes": {
            "type": "array",
            "items": {
              "type": "integer",
              "format": "uint8",
              "minimum": 0.0
            },
            "maxItems": 32,
            "minItems": 32
          }
        }
      },
      "Uint128": {
        "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
        "type": "string"
      }
    }
  },
  "query": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "QueryMsg",
    "oneOf": [
      {
        "type": "object",
        "required": [
          "wrapped_registry"
        ],
        "properties": {
          "wrapped_registry": {
            "type": "object",
            "required": [
              "address",
              "chain"
            ],
            "properties": {
              "address": {
                "$ref": "#/definitions/Binary"
              },
              "chain": {
                "type": "integer",
                "format": "uint16",
                "minimum": 0.0
              }
            }
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "transfer_info"
        ],
        "properties": {
          "transfer_info": {
            "type": "object",
            "required": [
              "vaa"
            ],
            "properties": {
              "vaa": {
                "$ref": "#/definitions/Binary"
              }
            }
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "external_id"
        ],
        "properties": {
          "external_id": {
            "type": "object",
            "required": [
              "external_id"
            ],
            "properties": {
              "external_id": {
                "$ref": "#/definitions/Binary"
              }
            }
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "is_vaa_redeemed"
        ],
        "properties": {
          "is_vaa_redeemed": {
            "type": "object",
            "required": [
              "vaa"
            ],
            "properties": {
              "vaa": {
                "$ref": "#/definitions/Binary"
              }
            }
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "chain_registration"
        ],
        "properties": {
          "chain_registration": {
            "type": "object",
            "required": [
              "chain"
            ],
            "properties": {
              "chain": {
                "type": "integer",
                "format": "uint16",
                "minimum": 0.0
              }
            }
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "Binary": {
        "description": "Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.\n\nThis is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>",
        "type": "string"
      }
    }
  },
  "migrate": null,
  "sudo": null,
  "responses": {
    "chain_registration": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "ChainRegistrationResponse",
      "type": "object",
      "required": [
        "address"
      ],
      "properties": {
        "address": {
          "$ref": "#/definitions/Binary"
        }
      },
      "definitions": {
        "Binary": {
          "description": "Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.\n\nThis is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>",
          "type": "string"
        }
      }
    },
    "external_id": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "ExternalIdResponse",
      "type": "object",
      "required": [
        "token_id"
      ],
      "properties": {
        "token_id": {
          "$ref": "#/definitions/TokenId"
        }
      },
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "ContractId": {
          "description": "A contract id is either a native cw20 address, or a foreign token. The reason we represent the foreign address here instead of storing the wrapped CW20 contract's address directly is that the wrapped asset might not be deployed yet.",
          "oneOf": [
            {
              "type": "object",
              "required": [
                "NativeCW20"
              ],
              "properties": {
                "NativeCW20": {
                  "type": "object",
                  "required": [
                    "contract_address"
                  ],
                  "properties": {
                    "contract_address": {
                      "$ref": "#/definitions/Addr"
                    }
                  }
                }
              },
              "additionalProperties": false
            },
            {
              "description": "A wrapped token might not exist yet.",
              "type": "object",
              "required": [
                "ForeignToken"
              ],
              "properties": {
                "ForeignToken": {
                  "type": "object",
                  "required": [
                    "chain_id",
                    "foreign_address"
                  ],
                  "properties": {
                    "chain_id": {
                      "type": "integer",
                      "format": "uint16",
                      "minimum": 0.0
                    },
                    "foreign_address": {
                      "type": "array",
                      "items": {
                        "type": "integer",
                        "format": "uint8",
                        "minimum": 0.0
                      },
                      "maxItems": 32,
                      "minItems": 32
                    }
                  }
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "TokenId": {
          "description": "Internal view of an address. This type is similar to [`AssetInfo`], but more granular. We do differentiate between bank tokens and CW20 tokens, but in the latter case, we further differentiate between native CW20s and wrapped CW20s (see [`ContractId`]).",
          "oneOf": [
            {
              "type": "object",
              "required": [
                "Bank"
              ],
              "properties": {
                "Bank": {
                  "type": "object",
                  "required": [
                    "denom"
                  ],
                  "properties": {
                    "denom": {
                      "type": "string"
                    }
                  }
                }
              },
              "additionalProperties": false
            },
            {
              "type": "object",
              "required": [
                "Contract"
              ],
              "properties": {
                "Contract": {
                  "$ref": "#/definitions/ContractId"
                }
              },
              "additionalProperties": false
            }
          ]
        }
      }
    },
    "is_vaa_redeemed": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "IsVaaRedeemedResponse",
      "type": "object",
      "required": [
        "is_redeemed"
      ],
      "properties": {
        "is_redeemed": {
          "type": "boolean"
        }
      }
    },
    "transfer_info": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "TransferInfoResponse",
      "type": "object",
      "required": [
        "amount",
        "fee",
        "payload",
        "recipient",
        "recipient_chain",
        "token_address",
        "token_chain"
      ],
      "properties": {
        "amount": {
          "$ref": "#/definitions/Uint128"
        },
        "fee": {
          "$ref": "#/definitions/Uint128"
        },
        "payload": {
          "type": "array",
          "items": {
            "type": "integer",
            "format": "uint8",
            "minimum": 0.0
          }
        },
        "recipient": {
          "type": "array",
          "items": {
            "type": "integer",
            "format": "uint8",
            "minimum": 0.0
          },
          "maxItems": 32,
          "minItems": 32
        },
        "recipient_chain": {
          "type": "integer",
          "format": "uint16",
          "minimum": 0.0
        },
        "token_address": {
          "type": "array",
          "items": {
            "type": "integer",
            "format": "uint8",
            "minimum": 0.0
          },
          "maxItems": 32,
          "minItems": 32
        },
        "token_chain": {
          "type": "integer",
          "format": "uint16",
          "minimum": 0.0
        }
      },
      "definitions": {
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "wrapped_registry": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "WrappedRegistryResponse",
      "type": "object",
      "required": [
        "address"
      ],
      "properties": {
        "address": {
          "type": "string"
        }
      }
    }
  }
}
