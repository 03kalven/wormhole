/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.24.0.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { Coin } from "@cosmjs/amino";
import { MsgExecuteContractEncodeObject } from "cosmwasm";
import { MsgExecuteContract } from "cosmjs-types/cosmwasm/wasm/v1/tx";
import { toUtf8 } from "@cosmjs/encoding";
import { Binary, InstantiateMsg, ExecuteMsg, AssetInfo, Uint128, ExternalTokenId, Asset, QueryMsg, ChainRegistrationResponse, TokenId, ContractId, Addr, ExternalIdResponse, IsVaaRedeemedResponse, TransferInfoResponse, WrappedRegistryResponse } from "./TokenBridge.types";
export interface TokenBridgeMessage {
  contractAddress: string;
  sender: string;
  registerAssetHook: ({
    chain,
    tokenAddress
  }: {
    chain: number;
    tokenAddress: ExternalTokenId;
  }, funds?: Coin[]) => MsgExecuteContractEncodeObject;
  depositTokens: (funds?: Coin[]) => MsgExecuteContractEncodeObject;
  withdrawTokens: ({
    asset
  }: {
    asset: AssetInfo;
  }, funds?: Coin[]) => MsgExecuteContractEncodeObject;
  initiateTransfer: ({
    asset,
    fee,
    nonce,
    recipient,
    recipientChain
  }: {
    asset: Asset;
    fee: Uint128;
    nonce: number;
    recipient: Binary;
    recipientChain: number;
  }, funds?: Coin[]) => MsgExecuteContractEncodeObject;
  initiateTransferWithPayload: ({
    asset,
    fee,
    nonce,
    payload,
    recipient,
    recipientChain
  }: {
    asset: Asset;
    fee: Uint128;
    nonce: number;
    payload: Binary;
    recipient: Binary;
    recipientChain: number;
  }, funds?: Coin[]) => MsgExecuteContractEncodeObject;
  submitVaa: ({
    data
  }: {
    data: Binary;
  }, funds?: Coin[]) => MsgExecuteContractEncodeObject;
  createAssetMeta: ({
    assetInfo,
    nonce
  }: {
    assetInfo: AssetInfo;
    nonce: number;
  }, funds?: Coin[]) => MsgExecuteContractEncodeObject;
  completeTransferWithPayload: ({
    data,
    relayer
  }: {
    data: Binary;
    relayer: string;
  }, funds?: Coin[]) => MsgExecuteContractEncodeObject;
}
export class TokenBridgeMessageComposer implements TokenBridgeMessage {
  sender: string;
  contractAddress: string;

  constructor(sender: string, contractAddress: string) {
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.registerAssetHook = this.registerAssetHook.bind(this);
    this.depositTokens = this.depositTokens.bind(this);
    this.withdrawTokens = this.withdrawTokens.bind(this);
    this.initiateTransfer = this.initiateTransfer.bind(this);
    this.initiateTransferWithPayload = this.initiateTransferWithPayload.bind(this);
    this.submitVaa = this.submitVaa.bind(this);
    this.createAssetMeta = this.createAssetMeta.bind(this);
    this.completeTransferWithPayload = this.completeTransferWithPayload.bind(this);
  }

  registerAssetHook = ({
    chain,
    tokenAddress
  }: {
    chain: number;
    tokenAddress: ExternalTokenId;
  }, funds?: Coin[]): MsgExecuteContractEncodeObject => {
    return {
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
      value: MsgExecuteContract.fromPartial({
        sender: this.sender,
        contract: this.contractAddress,
        msg: toUtf8(JSON.stringify({
          register_asset_hook: {
            chain,
            token_address: tokenAddress
          }
        })),
        funds
      })
    };
  };
  depositTokens = (funds?: Coin[]): MsgExecuteContractEncodeObject => {
    return {
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
      value: MsgExecuteContract.fromPartial({
        sender: this.sender,
        contract: this.contractAddress,
        msg: toUtf8(JSON.stringify({
          deposit_tokens: {}
        })),
        funds
      })
    };
  };
  withdrawTokens = ({
    asset
  }: {
    asset: AssetInfo;
  }, funds?: Coin[]): MsgExecuteContractEncodeObject => {
    return {
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
      value: MsgExecuteContract.fromPartial({
        sender: this.sender,
        contract: this.contractAddress,
        msg: toUtf8(JSON.stringify({
          withdraw_tokens: {
            asset
          }
        })),
        funds
      })
    };
  };
  initiateTransfer = ({
    asset,
    fee,
    nonce,
    recipient,
    recipientChain
  }: {
    asset: Asset;
    fee: Uint128;
    nonce: number;
    recipient: Binary;
    recipientChain: number;
  }, funds?: Coin[]): MsgExecuteContractEncodeObject => {
    return {
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
      value: MsgExecuteContract.fromPartial({
        sender: this.sender,
        contract: this.contractAddress,
        msg: toUtf8(JSON.stringify({
          initiate_transfer: {
            asset,
            fee,
            nonce,
            recipient,
            recipient_chain: recipientChain
          }
        })),
        funds
      })
    };
  };
  initiateTransferWithPayload = ({
    asset,
    fee,
    nonce,
    payload,
    recipient,
    recipientChain
  }: {
    asset: Asset;
    fee: Uint128;
    nonce: number;
    payload: Binary;
    recipient: Binary;
    recipientChain: number;
  }, funds?: Coin[]): MsgExecuteContractEncodeObject => {
    return {
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
      value: MsgExecuteContract.fromPartial({
        sender: this.sender,
        contract: this.contractAddress,
        msg: toUtf8(JSON.stringify({
          initiate_transfer_with_payload: {
            asset,
            fee,
            nonce,
            payload,
            recipient,
            recipient_chain: recipientChain
          }
        })),
        funds
      })
    };
  };
  submitVaa = ({
    data
  }: {
    data: Binary;
  }, funds?: Coin[]): MsgExecuteContractEncodeObject => {
    return {
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
      value: MsgExecuteContract.fromPartial({
        sender: this.sender,
        contract: this.contractAddress,
        msg: toUtf8(JSON.stringify({
          submit_vaa: {
            data
          }
        })),
        funds
      })
    };
  };
  createAssetMeta = ({
    assetInfo,
    nonce
  }: {
    assetInfo: AssetInfo;
    nonce: number;
  }, funds?: Coin[]): MsgExecuteContractEncodeObject => {
    return {
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
      value: MsgExecuteContract.fromPartial({
        sender: this.sender,
        contract: this.contractAddress,
        msg: toUtf8(JSON.stringify({
          create_asset_meta: {
            asset_info: assetInfo,
            nonce
          }
        })),
        funds
      })
    };
  };
  completeTransferWithPayload = ({
    data,
    relayer
  }: {
    data: Binary;
    relayer: string;
  }, funds?: Coin[]): MsgExecuteContractEncodeObject => {
    return {
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
      value: MsgExecuteContract.fromPartial({
        sender: this.sender,
        contract: this.contractAddress,
        msg: toUtf8(JSON.stringify({
          complete_transfer_with_payload: {
            data,
            relayer
          }
        })),
        funds
      })
    };
  };
}