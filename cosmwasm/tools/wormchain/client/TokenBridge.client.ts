// @ts-nocheck
/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.24.0.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { Coin, StdFee } from "@cosmjs/amino";
import { Binary, InstantiateMsg, ExecuteMsg, AssetInfo, Uint128, ExternalTokenId, Asset, QueryMsg, ChainRegistrationResponse, TokenId, ContractId, Addr, ExternalIdResponse, IsVaaRedeemedResponse, TransferInfoResponse, WrappedRegistryResponse } from "./TokenBridge.types";
export interface TokenBridgeReadOnlyInterface {
  contractAddress: string;
  wrappedRegistry: ({
    address,
    chain
  }: {
    address: Binary;
    chain: number;
  }) => Promise<WrappedRegistryResponse>;
  transferInfo: ({
    vaa
  }: {
    vaa: Binary;
  }) => Promise<TransferInfoResponse>;
  externalId: ({
    externalId
  }: {
    externalId: Binary;
  }) => Promise<ExternalIdResponse>;
  isVaaRedeemed: ({
    vaa
  }: {
    vaa: Binary;
  }) => Promise<IsVaaRedeemedResponse>;
  chainRegistration: ({
    chain
  }: {
    chain: number;
  }) => Promise<ChainRegistrationResponse>;
}
export class TokenBridgeQueryClient implements TokenBridgeReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.wrappedRegistry = this.wrappedRegistry.bind(this);
    this.transferInfo = this.transferInfo.bind(this);
    this.externalId = this.externalId.bind(this);
    this.isVaaRedeemed = this.isVaaRedeemed.bind(this);
    this.chainRegistration = this.chainRegistration.bind(this);
  }

  wrappedRegistry = async ({
    address,
    chain
  }: {
    address: Binary;
    chain: number;
  }): Promise<WrappedRegistryResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      wrapped_registry: {
        address,
        chain
      }
    });
  };
  transferInfo = async ({
    vaa
  }: {
    vaa: Binary;
  }): Promise<TransferInfoResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      transfer_info: {
        vaa
      }
    });
  };
  externalId = async ({
    externalId
  }: {
    externalId: Binary;
  }): Promise<ExternalIdResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      external_id: {
        external_id: externalId
      }
    });
  };
  isVaaRedeemed = async ({
    vaa
  }: {
    vaa: Binary;
  }): Promise<IsVaaRedeemedResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      is_vaa_redeemed: {
        vaa
      }
    });
  };
  chainRegistration = async ({
    chain
  }: {
    chain: number;
  }): Promise<ChainRegistrationResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      chain_registration: {
        chain
      }
    });
  };
}
export interface TokenBridgeInterface extends TokenBridgeReadOnlyInterface {
  contractAddress: string;
  sender: string;
  registerAssetHook: ({
    chain,
    tokenAddress
  }: {
    chain: number;
    tokenAddress: ExternalTokenId;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  depositTokens: (fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  withdrawTokens: ({
    asset
  }: {
    asset: AssetInfo;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  initiateTransfer: ({
    asset,
    fee,
    nonce,
    recipient,
    recipientChain
  }: {
    asset: Asset;
    fee: Uint128;
    nonce: number;
    recipient: Binary;
    recipientChain: number;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  initiateTransferWithPayload: ({
    asset,
    fee,
    nonce,
    payload,
    recipient,
    recipientChain
  }: {
    asset: Asset;
    fee: Uint128;
    nonce: number;
    payload: Binary;
    recipient: Binary;
    recipientChain: number;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  submitVaa: ({
    data
  }: {
    data: Binary;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  createAssetMeta: ({
    assetInfo,
    nonce
  }: {
    assetInfo: AssetInfo;
    nonce: number;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  completeTransferWithPayload: ({
    data,
    relayer
  }: {
    data: Binary;
    relayer: string;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
}
export class TokenBridgeClient extends TokenBridgeQueryClient implements TokenBridgeInterface {
  override client: SigningCosmWasmClient;
  sender: string;
  override contractAddress: string;

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.registerAssetHook = this.registerAssetHook.bind(this);
    this.depositTokens = this.depositTokens.bind(this);
    this.withdrawTokens = this.withdrawTokens.bind(this);
    this.initiateTransfer = this.initiateTransfer.bind(this);
    this.initiateTransferWithPayload = this.initiateTransferWithPayload.bind(this);
    this.submitVaa = this.submitVaa.bind(this);
    this.createAssetMeta = this.createAssetMeta.bind(this);
    this.completeTransferWithPayload = this.completeTransferWithPayload.bind(this);
  }

  registerAssetHook = async ({
    chain,
    tokenAddress
  }: {
    chain: number;
    tokenAddress: ExternalTokenId;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      register_asset_hook: {
        chain,
        token_address: tokenAddress
      }
    }, fee, memo, funds);
  };
  depositTokens = async (fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      deposit_tokens: {}
    }, fee, memo, funds);
  };
  withdrawTokens = async ({
    asset
  }: {
    asset: AssetInfo;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      withdraw_tokens: {
        asset
      }
    }, fee, memo, funds);
  };
  initiateTransfer = async ({
    asset,
    fee,
    nonce,
    recipient,
    recipientChain
  }: {
    asset: Asset;
    fee: Uint128;
    nonce: number;
    recipient: Binary;
    recipientChain: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      initiate_transfer: {
        asset,
        fee,
        nonce,
        recipient,
        recipient_chain: recipientChain
      }
    }, fee, memo, funds);
  };
  initiateTransferWithPayload = async ({
    asset,
    fee,
    nonce,
    payload,
    recipient,
    recipientChain
  }: {
    asset: Asset;
    fee: Uint128;
    nonce: number;
    payload: Binary;
    recipient: Binary;
    recipientChain: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      initiate_transfer_with_payload: {
        asset,
        fee,
        nonce,
        payload,
        recipient,
        recipient_chain: recipientChain
      }
    }, fee, memo, funds);
  };
  submitVaa = async ({
    data
  }: {
    data: Binary;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      submit_vaa: {
        data
      }
    }, fee, memo, funds);
  };
  createAssetMeta = async ({
    assetInfo,
    nonce
  }: {
    assetInfo: AssetInfo;
    nonce: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      create_asset_meta: {
        asset_info: assetInfo,
        nonce
      }
    }, fee, memo, funds);
  };
  completeTransferWithPayload = async ({
    data,
    relayer
  }: {
    data: Binary;
    relayer: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      complete_transfer_with_payload: {
        data,
        relayer
      }
    }, fee, memo, funds);
  };
}
