/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.24.0.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { Coin, StdFee } from "@cosmjs/amino";
import { Binary, InstantiateMsg, Signature, ExecuteMsg, QueryMsg, TokenAddress, Uint256, Key, Transfer, Data, Balance, AllAccountsResponse, Account, Kind, AllModificationsResponse, Modification, AllPendingTransfersResponse, PendingTransfer, Observation, AllTransfersResponse, Empty } from "./WormchainAccounting.types";
export interface WormchainAccountingReadOnlyInterface {
  contractAddress: string;
  balance: ({
    emitterAddress,
    emitterChain,
    sequence
  }: {
    emitterAddress: TokenAddress;
    emitterChain: number;
    sequence: number;
  }) => Promise<Balance>;
  allAccounts: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: Key;
  }) => Promise<AllAccountsResponse>;
  transfer: ({
    emitterAddress,
    emitterChain,
    sequence
  }: {
    emitterAddress: TokenAddress;
    emitterChain: number;
    sequence: number;
  }) => Promise<Data>;
  allTransfers: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: Key;
  }) => Promise<AllTransfersResponse>;
  pendingTransfer: ({
    emitterAddress,
    emitterChain,
    sequence
  }: {
    emitterAddress: TokenAddress;
    emitterChain: number;
    sequence: number;
  }) => Promise<Data>;
  allPendingTransfers: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: Key;
  }) => Promise<AllPendingTransfersResponse>;
  modification: ({
    sequence
  }: {
    sequence: number;
  }) => Promise<Modification>;
  allModifications: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number;
  }) => Promise<AllModificationsResponse>;
  validateTransfer: ({
    transfer
  }: {
    transfer: Transfer;
  }) => Promise<Empty>;
}
export class WormchainAccountingQueryClient implements WormchainAccountingReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.balance = this.balance.bind(this);
    this.allAccounts = this.allAccounts.bind(this);
    this.transfer = this.transfer.bind(this);
    this.allTransfers = this.allTransfers.bind(this);
    this.pendingTransfer = this.pendingTransfer.bind(this);
    this.allPendingTransfers = this.allPendingTransfers.bind(this);
    this.modification = this.modification.bind(this);
    this.allModifications = this.allModifications.bind(this);
    this.validateTransfer = this.validateTransfer.bind(this);
  }

  balance = async ({
    emitterAddress,
    emitterChain,
    sequence
  }: {
    emitterAddress: TokenAddress;
    emitterChain: number;
    sequence: number;
  }): Promise<Balance> => {
    return this.client.queryContractSmart(this.contractAddress, {
      balance: {
        emitter_address: emitterAddress,
        emitter_chain: emitterChain,
        sequence
      }
    });
  };
  allAccounts = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: Key;
  }): Promise<AllAccountsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      all_accounts: {
        limit,
        start_after: startAfter
      }
    });
  };
  transfer = async ({
    emitterAddress,
    emitterChain,
    sequence
  }: {
    emitterAddress: TokenAddress;
    emitterChain: number;
    sequence: number;
  }): Promise<Data> => {
    return this.client.queryContractSmart(this.contractAddress, {
      transfer: {
        emitter_address: emitterAddress,
        emitter_chain: emitterChain,
        sequence
      }
    });
  };
  allTransfers = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: Key;
  }): Promise<AllTransfersResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      all_transfers: {
        limit,
        start_after: startAfter
      }
    });
  };
  pendingTransfer = async ({
    emitterAddress,
    emitterChain,
    sequence
  }: {
    emitterAddress: TokenAddress;
    emitterChain: number;
    sequence: number;
  }): Promise<Data> => {
    return this.client.queryContractSmart(this.contractAddress, {
      pending_transfer: {
        emitter_address: emitterAddress,
        emitter_chain: emitterChain,
        sequence
      }
    });
  };
  allPendingTransfers = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: Key;
  }): Promise<AllPendingTransfersResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      all_pending_transfers: {
        limit,
        start_after: startAfter
      }
    });
  };
  modification = async ({
    sequence
  }: {
    sequence: number;
  }): Promise<Modification> => {
    return this.client.queryContractSmart(this.contractAddress, {
      modification: {
        sequence
      }
    });
  };
  allModifications = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number;
  }): Promise<AllModificationsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      all_modifications: {
        limit,
        start_after: startAfter
      }
    });
  };
  validateTransfer = async ({
    transfer
  }: {
    transfer: Transfer;
  }): Promise<Empty> => {
    return this.client.queryContractSmart(this.contractAddress, {
      validate_transfer: {
        transfer
      }
    });
  };
}
export interface WormchainAccountingInterface extends WormchainAccountingReadOnlyInterface {
  contractAddress: string;
  sender: string;
  submitObservations: ({
    guardianSetIndex,
    observations,
    signature
  }: {
    guardianSetIndex: number;
    observations: Binary;
    signature: Signature;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  modifyBalance: ({
    guardianSetIndex,
    modification,
    signatures
  }: {
    guardianSetIndex: number;
    modification: Binary;
    signatures: Signature[];
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  upgradeContract: ({
    guardianSetIndex,
    signatures,
    upgrade
  }: {
    guardianSetIndex: number;
    signatures: Signature[];
    upgrade: Binary;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  submitVAAs: ({
    vaas
  }: {
    vaas: Binary[];
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
}
export class WormchainAccountingClient extends WormchainAccountingQueryClient implements WormchainAccountingInterface {
  override client: SigningCosmWasmClient;
  sender: string;
  override contractAddress: string;

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.submitObservations = this.submitObservations.bind(this);
    this.modifyBalance = this.modifyBalance.bind(this);
    this.upgradeContract = this.upgradeContract.bind(this);
    this.submitVAAs = this.submitVAAs.bind(this);
  }

  submitObservations = async ({
    guardianSetIndex,
    observations,
    signature
  }: {
    guardianSetIndex: number;
    observations: Binary;
    signature: Signature;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      submit_observations: {
        guardian_set_index: guardianSetIndex,
        observations,
        signature
      }
    }, fee, memo, funds);
  };
  modifyBalance = async ({
    guardianSetIndex,
    modification,
    signatures
  }: {
    guardianSetIndex: number;
    modification: Binary;
    signatures: Signature[];
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      modify_balance: {
        guardian_set_index: guardianSetIndex,
        modification,
        signatures
      }
    }, fee, memo, funds);
  };
  upgradeContract = async ({
    guardianSetIndex,
    signatures,
    upgrade
  }: {
    guardianSetIndex: number;
    signatures: Signature[];
    upgrade: Binary;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      upgrade_contract: {
        guardian_set_index: guardianSetIndex,
        signatures,
        upgrade
      }
    }, fee, memo, funds);
  };
  submitVAAs = async ({
    vaas
  }: {
    vaas: Binary[];
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      submit_v_a_as: {
        vaas
      }
    }, fee, memo, funds);
  };
}